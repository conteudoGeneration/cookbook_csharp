<h1>Collections (Cole√ß√µes)</h1>

A linguagem C# suporta arrays para armazenar v√°rios objetos, entretanto, quando uma matriz √© inicializada, ela √© definida com um tamanho pr√©-definido durante o processo de instancia√ß√£o, como vimos no anteriormente. Esta limita√ß√£o causa alguns problemas para n√≥s pessoas desenvolvedoras, pois quando estamos trabalhando com grandes volumes de dados, fica muito dif√≠cil mensurar o n√∫mero de Objetos que iremos armazenar em uma Matriz. Para suportar estruturas de dados mais flex√≠veis, ou seja, sem tamanho pr√©-definido, o C# nos fornece a **Classe Collections** (Cole√ß√£o). 

Uma Cole√ß√£o √© uma Estrutura de Dados que cont√©m e processa um conjunto de dados. Os dados armazenados na cole√ß√£o s√£o encapsulados e o acesso aos dados s√≥ √© poss√≠vel por meio de m√©todos predefinidos. 

**Exemplo:** A pessoa desenvolvedora pode adicionar elementos a uma cole√ß√£o por meio de um m√©todo. 

As cole√ß√µes usam Matrizes internas para o armazenamento, mas ocultam da pessoa desenvolvedora a complexidade de gerenciar o tamanho da Matriz de forma din√¢mica.

As Cole√ß√µes oferecem diversas formas de armazenar os dados com base em fatores como:

- Efici√™ncia no acesso, na busca ou na inser√ß√£o;
- Forma de organiza√ß√£o dos dados;
- Forma de acesso, busca e inser√ß√£o dos dados

Para gerenciar todas estas estruturas de dados, o C# nos oferece as **Collections**.

<br />

<h2>1. Collections</h2>

**Collections** √© uma biblioteca de classes e interfaces (no pacote **System.Collections.***), que implementa as principais estruturas de dados de forma reutiliz√°vel. 

<br />

<h3>1.1. Tipos de Collections</h3>

##### **Tipos de cole√ß√µes em C#**

Existem 3 maneiras de trabalhar com Collections no C#:

1. **Collections N√£o Gen√©ricas**, que operam em objetos e, portanto,  podem lidar com qualquer tipo de dados, mas n√£o de maneira segura, devido a aus√™ncia de uma tipagem dos dados.
2. **Collections Gen√©ricas**, que fornece uma implementa√ß√£o gen√©rica de estruturas de dados padr√£o, com a seguran√ßa da tipagem porque s√£o gen√©ricas, ou seja, apenas os itens que s√£o compat√≠veis com o tipo da cole√ß√£o  podem ser armazenados em uma cole√ß√£o gen√©rica, eliminando incompatibilidades acidentais de tipo.
3. **Collections Concorrentes**, que s√£o semelhantes as Collections Gen√©ricas com a diferen√ßa que permitem o processamento paralelo ou concorrente, ou seja, processamento ass√≠ncrono.

Neste material focaremos nas Collections Gen√©ricas, que trabalham com processamento s√≠ncrono e s√£o fortemente tipadas.

<br />

<h3>1.2. Collections Gen√©ricas (Generics)</h3>

No Organograma abaixo, temos uma vis√£o geral do Pacote Collections:

<div align="center"><img src="https://i.imgur.com/tY7s9fc.png" title="source: imgur.com" /></div>

A Collection **List** (Lista) √© muito semelhante a um Array. **Os elementos em uma lista s√£o ordenados como uma sequ√™ncia**. O usu√°rio pode utilizar o  n√∫mero do √≠ndice para acessar um determinado elemento da lista, ou seja, o usu√°rio tem controle total sobre qual elemento est√° inserido na lista. A Interface List √© como um array de tamanho vari√°vel. 

Fazendo uma analogia com Blocos de montar, uma **List** seria como uma sequ√™ncia de blocos numerados (√≠ndices), como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/0Oq8S5J.png" title="source: imgur.com" /></div>

<br />

A Collection **Stack**, implementa a estrutura de dados chamada Pilha. Uma **Pilha** √© uma estrutura de dados do tipo **LIFO**: *"O √∫ltimo elemento inserido na pilha √© o primeiro elemento que ser√° retirado da pilha."* (**Last In -  First Out**). 

Fazendo uma analogia com Blocos de montar, uma **Stack** seria como uma pilha de blocos, um em cima do outro, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/WNPT9AV.png" title="source: imgur.com" /></div>

A Estrutura de dados pilha pode ser representada no mundo real como uma pilha de pratos em um restaurante, onde ultimo prato inserido na pilha, ser√° o primeiro prato a ser utilizado no restaurante.

A Collection **Queue** (Fila) √© uma implementa√ß√£o da Estrutura de Dados conhecida como fila, onde *"O primeiro elemento adicionado, ser√° primeiro elemento a ser retirado da fila"* (**FIFO - First in, First out**). 

Fazendo uma analogia com Blocos de montar, uma **Fila** seria como uma sequ√™ncia de blocos, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/R4NFtpj.png" title="source: imgur.com" /></div>

A Estrutura de dados fila pode ser representada no mundo real como uma fila de pessoas em um balc√£o, onde a pessoa que entra primeiro ser√° atendida primeiro e log sai da fila primeiro.

A Collection **HashSet** √© uma estrutura que modela a defini√ß√£o matem√°tica de um conjunto de dados. √â uma cole√ß√£o de objetos, que **n√£o permite objetos duplicados**. O conjunto permite no m√°ximo um elemento nulo. 

Fazendo uma analogia com Blocos de montar, um **HashSet** seria como uma cole√ß√£o de blocos, ou seja, um conjunto, sem elementos repetidos, n√£o ordenados, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/wLBchdt.png" title="source: imgur.com" /></div>

A Collection **HashSet** √© uma das mais r√°pidas, porque internamente ela implementa a Estrutura de Dados **Hash** ou **Hashing**. Essa implementa√ß√£o √© indicada se voc√™ precisa apenas garantir a alta performance, garantindo que n√£o existam elementos duplicados, sem se importar com a ordena√ß√£o dos elementos. Nos pr√≥ximos t√≥picos, veremos esta Estrutura de dados com mais detalhes. 

> **Hash** significa usar alguma fun√ß√£o ou algoritmo para mapear os dados do objeto para algum valor inteiro representativo. Este chamado c√≥digo de hash (ou simplesmente hash) pode ent√£o ser usado como um modo de reduzir a nossa busca ao procurar o item no mapa. Geralmente, esses c√≥digos  hash s√£o usados para gerar um √≠ndice, no qual o valor √© armazenado.
>
> **Hash Code** √© um valor inteiro que identifica um valor espec√≠fico. Atrav√©s do c√≥digo Hash podemos comparar dois objetos para ver se eles s√£o iguais. √â por isso que usamos um c√≥digo hash como um valor em uma cole√ß√£o HashSet: Comparar o valor inteiro √© muito mais r√°pido do que comparar dois objetos usando o m√©todo equals ou strings, que podem conter acentos e caracteres .

<br />

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="80px"/> | <div align="left"> **ATEN√á√ÉO:** *N√£o se preocupe neste momento com o conceito de Objeto. Mais a frente, vamos aprofundar este e outros conceitos ao falarmos sobre Orienta√ß√£o a Objetos com a Linguagem C#.* </div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

A Collection **SortedSet** √© semelhante a Collection **HashSet**, com a diferen√ßa que ela mant√©m os elementos da Collection ordenados automaticamente, independente da  ordem que voc√™ inserir os elementos. Essa Ordena√ß√£o dos elementos tem um custo de performance em rela√ß√£o a Collection **HashSet**.

A Collection **Dictionary** (Dicion√°rio) define um array associativo, isto √©, ao inv√©s de utilizar n√∫meros inteiros como √≠ndices, objetos s√£o utilizados como chaves para recuperar os elementos armazenados nesta Collection. As chaves n√£o podem se repetir (seguindo o mesmo princ√≠pio da interface ISet), mas os valores podem ser repetidos para chaves diferentes. Um Dictionary tamb√©m n√£o possui necessariamente uma ordem definida para percorrer a cole√ß√£o. 

Fazendo uma analogia com Blocos de montar, um **Dictionary** seria como uma sequ√™ncia de blocos numerados (√≠ndices), onde cada bloco possui um par Chave - Valor, como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/SHgQGZB.png" title="source: imgur.com" /></div>

O grande diferencial da Collection Dictionary s√£o as pesquisas r√°pidas por chaves. Na Collection List, procurar um cliente envolve uma pesquisa linear, percorrendo todos os √≠ndices, enquanto na Collection Dictionary as pesquisas s√£o muito mais r√°pidas porque a chave √© um valor que identifica exclusivamente um objeto, tornando a busca mais direta e Objetiva. 

A Collection **SortedDictionary** √© semelhante a Collection **Dictionary**, com a diferen√ßa que ela mant√©m os elementos da Collection ordenados de acordo com as chaves. Essa Ordena√ß√£o dos elementos tem um custo de performance em rela√ß√£o a Collection **Dictionary**.

A Collection **SortedList** funciona de forma id√™ntica a Collection **SortedDictionary**, a grande diferen√ßa est√° na performance. SortedDictionary √© implementado usando uma √°rvore de pesquisa bin√°ria, enquanto um  SortedList √© implementado usando dois arrays internos, onde um array aramazena as chaves e o outro armazena os valores. Um SortedList consome menos mem√≥ria do que um  SortedDictionary e oferece uma recupera√ß√£o mais r√°pida e indexada de chaves e valores. No entanto, um SortedDictionary fornece opera√ß√µes de inser√ß√£o e remo√ß√£o  mais r√°pidas do que um SortedList.

> Uma **√°rvore de pesquisa bin√°ria** √© uma estrutura de dados em forma de √°rvore bin√°ria baseada em n√≥s, onde todos os n√≥s da sub-√°rvore esquerda possuem  um valor num√©rico inferior ao n√≥ raiz e todos os n√≥s da sub-√°rvore direita possuem um valor superior ao n√≥ raiz.

**Qual escolher?**

Se voc√™ precisar realizar muitas pesquisas e menos opera√ß√µes de inser√ß√£o e exclus√£o, opte por um SortedList. Se voc√™ for adicionar muitos dados n√£o classificados e remover itens n√£o classificados da cole√ß√£o aleatoriamente e a mem√≥ria n√£o √© uma restri√ß√£o, opte por um SortedDictionary.

A Collection **LinkedList** ou Lista Ligada √© uma estrutura de dados linear, na qual os elementos n√£o s√£o armazenados em locais de mem√≥ria cont√≠guos (sequenciais). Os elementos em uma lista vinculada s√£o vinculados usando ponteiros internamente, que "apontam" para o endere√ßo de Mem√≥ria do pr√≥ximo item e para o endere√ßo de Mem√≥ria do item anterior.

> Os **Ponteiros** s√£o **vari√°veis especiais que apontam para uma √°rea de mem√≥ria**. Os ponteiros n√£o possuem a informa√ß√µes em si, mas dizem onde a informa√ß√£o est√° armazenada na Mem√≥ria. Na Linguagem C#, os Ponteiros atuam internamente na Linguagem C# e n√£o ficam vis√≠veis para as Pessoas Desenvolvedoras, como na Linguagem C, por exemplo.

Fazendo uma analogia com Blocos de montar, uma **LinkedList** seria como uma sequ√™ncia de blocos que possuem conex√µes (links) com o pr√≥ximo bloco (encadeada) e com o bloco anterior (duplamente encadeada), como mostra a imagem abaixo:

<div align="center"><img src="https://i.imgur.com/yccszbp.png" title="source: imgur.com" /></div>

<br />

<div align="left"><img src="https://i.imgur.com/DNV9Rxu.png" title="source: imgur.com" width="30px"/> <a href="https://learn.microsoft.com/pt-br/dotnet/csharp/programming-guide/concepts/collections" target="_blank"><b>Documenta√ß√£o: Collections</b></a></div>

<div align="left"><img src="https://i.imgur.com/DNV9Rxu.png" title="source: imgur.com" width="30px"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.generic?view=net-7.0" target="_blank"><b>Documenta√ß√£o: Collections - Generics</b></a></div>

<div align="left"><img src="https://i.imgur.com/DNV9Rxu.png" title="source: imgur.com" width="30px"/> <a href="https://learn.microsoft.com/pt-br/dotnet/standard/collections/when-to-use-generic-collections" target="_blank"><b>Documenta√ß√£o: Por que usar Collections Gen√©ricas?</b></a></div>

<div align="left"><img src="https://i.imgur.com/DNV9Rxu.png" title="source: imgur.com" width="30px"/> <a href="https://learn.microsoft.com/pt-br/dotnet/standard/collections/" target="_blank"><b>Documenta√ß√£o: Collections e Estruturas de Dados</b></a></div>

<br />

<h2>2. A Collection List</h2>

Em nosso curso, vamos estudar mais a fundo Collection List, por se tratar de uma escolha natural quando for necess√°rio usar um Array redimension√°vel, que √© muito mais eficiente para leitura, por ser implementado internamente com vetores, o que a torna ideal para o acesso aleat√≥rio aos dados armazenados.

**Sintaxe - Collection List Vazia:**

```c#
List<T> notas = new List<T>();
```

O construtor sem argumento padr√£o cria um Objeto da Classe List novo e vazio.

O item **`<T>`** em C#, representa um **C# Type Generic**. Ele √© utilizado para definir o tipo de dado que ser√° armazenado na Collection. O Tipo de dado pode ser um Primitivo ou um Objeto, que pode ser de uma **Classe criada pela pessoa desenvolvedora**.

**Sintaxe - Collection List inicializada:**

```c#
List<T> notas = new List<T>()
{
    elemento_01,
    elemento_02,
    elemento_...,
    elemento_N
};
```

Dentro do escopo (chaves), podemos inserir quantos elementos forem necess√°rios.

<br />

<h3>3.1. Principais M√©todos e Propriedades da Interface List</h3>

Na tabela abaixo, listamos os principais M√©todos para trabalharmos com a Collection List:

| **M√©todo / Propriedade**     | **Descri√ß√£o**                                                |
| ---------------------------- | ------------------------------------------------------------ |
| **Add(Elemento)**            | Adiciona  um elemento no final da lista.                     |
| **Insert(Indice, Elemento)** | Adiciona  um elemento na posi√ß√£o indicada (empurra elementos existentes para a frente) |
| **IndexOf(Elemento)**        | Procura  um elemento e retorna √≠ndice da primeira ocorr√™ncia do objeto. |
| **Remove(Elemento)**         | Apaga  um elemento armazenado na posi√ß√£o indicada pelo √≠ndice. |
| **Clear()**                  | Limpa  a lista                                               |
| **Count**                    | Retorna  o tamanho da lista (numero de elementos armazenados). |
| **Contains(Elemento)**       | Retorna  true se  existe uma ocorr√™ncia do elemento na lista. |
| **Sort()**                   | Ordena os elementos da lista em ordem crescente.             |
| **Reverse()**                | Ordena os elementos da lista em ordem decrescente.           |

Assim como no Array, o √≠ndice sempre inicia em 0.

<br />

## <img src="https://i.imgur.com/bm8Jxxm.png" title="source: imgur.com" width="3%"/> Exemplo 01 - Collection List:

No exemplo abaixo, vamos construir uma Collection List, chamada **notas**, contendo uma lista de notas. Os n√∫meros ser√£o Objetos da Classe Wrapper Double (lembre-se que Collections n√£o aceitam primitivos) e faremos alguns testes com os M√©todos da Collection List.

```c#
namespace collections_01
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // Cria a Collection List, do tipo Double, chamada notas e inicializa
            List<double> notas = new List<double>()
            {
                7.0,
                5.0,
                4.0,
                10.0
            };

            /* Mostra na tela todas as notas adicionadas.
               Observe que para exibir as notas utilizamos 
               o La√ßo foreach */
            Console.WriteLine("\nNotas cadastradas: ");

            foreach (double nota in notas)
            {
                Console.WriteLine(nota);
            }

            /*Adiciona uma nova Nota - duplicada */
            notas.Add(4.0);

            /**
             * Mostra na tela todas as notas, inclusive a 
             * nota duplicada que foi adicionada.
             */
            Console.WriteLine("\nNotas cadastradas: ");

            foreach(double nota in notas)
            {
                Console.WriteLine(nota);
            }

            /*Adiciona uma nova Nota na posi√ß√£o 2 da Lista */
            notas.Insert(2, 9.0);

            /**
             * Mostra na tela todas as notas, inclusive a 
             * nota 9.0 que foi adicionada na posi√ß√£o 2.
             */
            Console.WriteLine("\nNotas cadastradas: ");

            foreach (double nota in notas)
            {
                Console.WriteLine(nota);
            }

            /**
             * Mostra a posi√ß√£o (indice) de uma determinada nota. 
             * Caso existam 2 notas iguais ser√° exibida a posi√ß√£o da primeira nota encontrada.
             */
            Console.WriteLine("\nA posi√ß√£o da nota 5 √©: " + notas.IndexOf(5));

            // Mostra se uma determinada nota existe na lista
            Console.WriteLine("\nA nota 5 existe na lista? " + notas.Contains(5));

            // Mostra a nota inserida em uma determinada posi√ß√£o (indice)
            Console.WriteLine("\nNa posi√ß√£o 1 da lista, a nota √©: " + notas[1]);

            // Altera a nota 5.0 para 6.0 e mostra que a altera√ß√£o foi efetuada
            notas[notas.IndexOf(5)] = 6.0;
            Console.WriteLine("\nA nota 5 foi alterada para 6: ");

            foreach (double nota in notas)
            {
                Console.WriteLine(nota);
            }

            /**
             *  Apaga a nota 4.0 e mostra que a exclus√£o foi efetuada.
             *  Observe que apenas a primeira nota 4.0 foi apagada.
             */
            notas.Remove(4.0);
            Console.WriteLine("\nA nota 4 foi apagada: ");

            foreach (double nota in notas)
            {
                Console.WriteLine(nota);
            }

            // Exibe o tamanho da lista (numero de elementos)
            Console.WriteLine("\nO tamanho da lista √©: " + notas.Count);

            // Limpa a lista e mostra que ela est√° vazia
            notas.Clear();
            Console.WriteLine("\nA lista est√° vazia");

            foreach (double nota in notas)
            {
                Console.WriteLine(nota);
            }

        }
    }
}
```

O resultados deste exemplo, voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash

Notas cadastradas:
7
5
4
10

Notas cadastradas:
7
5
4
10
4

Notas cadastradas:
7
5
9
4
10
4

A posi√ß√£o da nota 5 √©: 1

A nota 5 existe na lista? True

Na posi√ß√£o 1 da lista, a nota √©: 5

A nota 5 foi alterada para 6:
7
6
9
4
10
4

A nota 4 foi apagada:
7
6
9
10
4

O tamanho da lista √©: 5

A lista est√° vazia
```

<br />

<h3>Como a Colection List ir√° armazenar os dados?</h3>

Na imagem abaixo, temos uma representa√ß√£o gr√°fica da Collection List **notas**:

 <div align="left"><img src="https://i.imgur.com/EdjxSQz.png" /></div>

Observe que a Collection **notas**, √© do tipo **double** e cada novo elemento (n√∫mero) ser√° adicionado em uma linha da Collection List. Assim como os vetores, cada linha √© identificada por um n√∫mero inteiro (√≠ndice).

A Collection List sempre respeita a ordem em que o Objeto foi inserido, ou seja, a cada novo Objeto inserido, uma nova linha ser√° criada ap√≥s o √∫ltimo Objeto adicionado.

<br />

<div align="left"><img src="https://i.imgur.com/DNV9Rxu.png" title="source: imgur.com" width="30px"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.generic.list-1?view=net-7.0" target="_blank"><b>Documenta√ß√£o: Collection List</b></a></div>

<br />

<h2>3. A Collection HashSet</h2>



A Collection **HashSet** √© uma cole√ß√£o de elementos n√£o ordenados, que n√£o permite o armazenamento de valores duplicados, ou seja, apenas valores √∫nicos. A Collection **HashSet** tamb√©m permite a inser√ß√£o de um √∫nico elemento nulo (NULL), embora n√£o seja recomendado.

Os objetos que inserimos na Collection HashSet ser√£o inseridos na mesma ordem e inclusive esta ordem n√£o pode ser modificada, porque esta Collection n√£o possui M√©todos de Ordena√ß√£o. A Collection HashSet n√£o possui um M√©todo para obter um Objeto a partir do seu √≠ndice, como vimos na Collection List. 

Como vimos anteriormente, a Collection **HashSet** √© baseada na Estrutura de dados **Hash**. Quando voc√™ adiciona um novo elemento no **HashSet**, o **Hash Code** do elemento √© automaticamente calculado e comparado com os C√≥digos Hash dos elementos que j√° est√£o armazenados na Collection. Desta forma, a Collection HashSet garante que elementos repetidos n√£o ser√£o inseridos na cole√ß√£o e que os itens semelhantes ser√£o agrupados em compartimentos, chamados **buckets** (baldes), que internamente s√£o **Arrays** que armazenam os elementos semelhantes. Gra√ßas a este modelo, quando voc√™ deseja obter um item, a Collection **HashSet** calcula o **Hash Code** e a partir dele identifica o **Bucket**. Uma vez identificado o Bucket, a Collection HashSet busca o elemento no respectivo Bucket, tornando a busca muito mais r√°pida e eficiente.

<div align="center"><img src="https://i.imgur.com/uxqyF6e.png" title="source: imgur.com" /></div>

Na imagem acima, Observe que cada elemento inserido no HashSet, o Hash Code √© calculado automaticamente. A partir do **Hash Code** √© definido em qual **Bucket** o elemento ser√° adicionado (caso o elemento seja √∫nico e exclusivo), ou se ele ser√° ignorado (caso seja um elemento repetido). Cada Bucket √© um Array com elementos semelhantes.

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="200px"/> | <div align="left"> **ALERTA DE BSM:** *Mantenha aten√ß√£o aos detalhes ao trabalhar com a Collection HashSet. O foco da Collection HashSet n√£o √© a ordena√ß√£o e a posi√ß√£o de inser√ß√£o dos elementos na Collection, e sim garantir a exclusividade dos seus elementos, ou seja, valores √∫nicos, sem repeti√ß√µes.*</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

<br />

**Sintaxe da Collection HashSet - Vazia:**

```java
HashSet<T> setNumeros = new HashSet<T>();
```

O construtor sem argumento padr√£o cria um Objeto da Classe HashSet novo e vazio.

O item **`<T>`** em C#, representa um **C# Type Generic**. Ele √© utilizado para definir o tipo de dado que ser√° armazenado na Collection. O Tipo de dado pode ser um Primitivo ou um Objeto, que pode ser de uma de uma **Classe criada pela pessoa desenvolvedora**.

**Sintaxe da Collection HashSet - Inicializada:**

```c#
HashSet<T> setNumeros = new HashSet<T>()
{
    elemento_01,
    elemento_02,
    elemento_...,
    elemento_N
};
```

Dentro do escopo (chaves), podemos inserir quantos elementos forem necess√°rios.

<br />

<h3>4.1. M√©todos da Collection Set</h3>

Na tabela abaixo, listamos os principais M√©todos para trabalharmos com a Collection HashSet:

| **M√©todo / Propriedade** | **Descri√ß√£o**                                                |
| ------------------------ | ------------------------------------------------------------ |
| **Add(Elemento)**        | Adiciona  um elemento no final da lista.                     |
| **Remove(Elemento)**     | Apaga  um elemento armazenado na posi√ß√£o indicada pelo √≠ndice. |
| **Clear()**              | Limpa  a lista                                               |
| **Count**                | Retorna  o tamanho da lista (numero de elementos armazenados). |
| **Contains(Elemento)**   | Retorna  true se  existe uma ocorr√™ncia do elemento na lista. |

<br />

## <img src="https://i.imgur.com/bm8Jxxm.png" title="source: imgur.com" width="3%"/> Exemplo 02 - Collection HashSet:

No exemplo abaixo, vamos construir uma Collection HashSet, chamada **setFrutas**, contendo uma lista de frutas. As frutas ser√£o do tipo string e faremos alguns testes com os M√©todos da Collection HashSet.

```c#
using System.Collections.Generic;

namespace collections_02
{
    internal class Program
    {
        static void Main(string[] args)
        {
            // Cria a Collection Hashset, do tipo string, chamada frutas e inicializa
            HashSet<string> setFrutas = new HashSet<string>()
            {
                "Abacate",
                "Banana",
                "Jaboticaba",
                "Kiwi",
                "Ma√ß√£",
                "Morango",
                "P√™ra",
                "Jaboticaba"
            };

            /* Mostra na tela todas as frutas adicionadas.
               Observe que para exibir as frutas utilizamos 
               o La√ßo foreach */

            Console.WriteLine("\nFrutas cadastradas: ");

            foreach (string fruta in setFrutas)
            {
                Console.WriteLine(fruta);
            }

            /*Adiciona novas Frutas*/
            setFrutas.Add("Kiwi");
            setFrutas.Add("Pitaya");
            setFrutas.Add("Amora");
            setFrutas.Add(null);
            setFrutas.Add("Caju");

            /**
             * Mostra os dados armazenados na Collection HashSet Observe 
             * que a fruta repetida n√£o foi inserida novamente
             */
            Console.WriteLine("\nFrutas cadastradas: ");

            foreach (string fruta in setFrutas)
            {
                Console.WriteLine(fruta);
            }

            // Verifica se um elemento est√° armazenado na Collection HashSet
            Console.WriteLine("\nExiste a fruta Kiwi? " + setFrutas.Contains("Kiwi"));

            // Remove um elemento da Collection
            setFrutas.Remove("Kiwi");
            
            Console.WriteLine("\nKiwi foi removida!");

            foreach (string fruta in setFrutas)
            {
                Console.WriteLine(fruta);
            }

            // Verifica ap√≥s a remo√ß√£o se o elemento ainda existe na Collection HashSet
            Console.WriteLine("\nExiste a fruta Kiwi na Collection? " + setFrutas.Contains("Kiwi"));

            // Limpa a Collection HashSet
            setFrutas.Clear();
            Console.WriteLine("\nTodos os itens foram removidos da Collection HashSet!");

        }
    }
}
```

O resultado deste exemplo, voc√™ confere abaixo:

<img src="https://i.imgur.com/V2ReOnx.png" title="source: imgur.com" width="3%"/> **Resultado do Algoritmo:**

```bash
Frutas cadastradas:
Abacate
Banana
Jaboticaba
Kiwi
Ma√ß√£
Morango
P√™ra

Frutas cadastradas:
Abacate
Banana
Jaboticaba
Kiwi
Ma√ß√£
Morango
P√™ra
Pitaya
Amora

Caju

Existe a fruta Kiwi? True

Kiwi foi removida!
Abacate
Banana
Jaboticaba
Ma√ß√£
Morango
P√™ra
Pitaya
Amora

Caju

Existe a fruta Kiwi na Collection? False

Todos os itens foram removidos da Collection HashSet!
```

<br />

<div align="left"><img src="https://i.imgur.com/DNV9Rxu.png" title="source: imgur.com" width="30px"/> <a href="https://learn.microsoft.com/pt-br/dotnet/api/system.collections.generic.hashset-1?view=net-7.0" target="_blank"><b>Documenta√ß√£o: Collection HashSet</b></a></div>

<br />

<div align="left"><img src="https://i.imgur.com/JACNZiR.png" title="source: imgur.com" width="5%"/> <a href="https://github.com/rafaelq80/exemplos_csharp/tree/main/09_collections" target="_blank"><b>C√≥digo Fonte dos Exemplos</b></a></div>

<br />

------

## üîë**Pontos chave:**

- **Collections (cole√ß√µes)** em C# s√£o tipos especiais de classes utilizadas para manipular grupos de dados do mesmo tipo (por exemplo, cole√ß√£o de strings), com tamanho flex√≠vel.
- **List** √© um tipo de estrutura de dados que cont√©m um n√∫mero fixo de valores de um √∫nico tipo
- **Queue (Fila)** √© um tipo de estrutura de dados que armazena valores sequenciais, onde o primeiro valor inserido, sempre ser√° o primeiro valor a ser retirado (First In - First Out).
- **Stack (Pilha)** √© um tipo de estrutura de dados que armazena valores sequenciais, onde o √∫ltimo valor inserido, sempre ser√° o primeiro valor a ser retirado (Last In - First Out).
- **HashSet** √© um tipo de estrutura de dados que armazena valores exclusivos do mesmo tipo (sem duplicatas)
- **Dictionary** √© um tipo de estrutura de dados utilizado para a pesquisa r√°pida de dados. Ele armazena dados na forma de pares de chave e valor.

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>
