<h1>Introdu√ß√£o a Seguran√ßa da aplica√ß√£o</h1>

<br />

<div align="center"><img src="https://i.imgur.com/iyARgVe.png" title="source: imgur.com" /></div>

No mundo da tecnologia, em especial da Internet, nenhuma aplica√ß√£o em execu√ß√£o na Nuvem pode ficar sem algum tipo de Seguran√ßa habilitada, devido aos in√∫meros perigos existentes no mundo virtual como ataques Hackers, invas√µes de Servidores, roubos de dados, entre outros.

Analisando nossos projetos, podemos perceber que nossas API's, at√© este momento, n√£o possuem nenhuma seguran√ßa, ou seja, qualquer pessoa pode acessar todos os nossos endpoints e terem acesso √† todos os recursos livremente. Como a maioria das aplica√ß√µes atuais cont√©m informa√ß√µes vitais como: dados pessoais dos usu√°rios e dos clientes, dados banc√°rios, usu√°rio e senha de acesso, precisamos garantir que a nossa API e estes dados estejam devidamente protegidos. No Ecossistema ASP.NET, podemos contar com os Pacotes **Authentication.JwtBearer** e **IdentityModel.Tokens.Jwt**, para implementar a seguran√ßa da nossa API.

Os Pacotes **Authentication.JwtBearer** e **IdentityModel.Tokens.Jwt** permitem implementar a autentica√ß√£o, autoriza√ß√£o, a valida√ß√£o do token e diversas outras funcionalidades para aplica√ß√µes corporativas, com o objetivo de proteger a aplica√ß√£o contra acessos indevidos.

<br />

<h2>1. Seguran√ßa da Aplica√ß√£o - Conceitos</h2>



Antes de implementarmos a seguran√ßa, vamos compreender alguns conceitos fundamentais sobre seguran√ßa de aplica√ß√µes:

<br />

<h3>1.1. Autentica√ß√£o</h3>

<div align="center"><img src="https://i.imgur.com/oljXzoD.png" title="source: imgur.com" /></div>

√â o primeiro processo da Seguran√ßa da Informa√ß√£o, popularmente conhecido como Login no sistema. √â o momento em que o usu√°rio informa o seu usu√°rio de login (e-mail) e a sua senha (criptografada), e o sistema far√° a checagem se estas informa√ß√µes est√£o corretas.

<br />

<h3>1.2. Token</h3>

<div align="center"><img src="https://i.imgur.com/13LBzxE.png" title="source: imgur.com" /></div>

Parte integrante da Autentica√ß√£o, um **Token** √© um dado, que aparentemente n√£o tem significado ou uso por si s√≥, mas quando combinado com o sistema de seguran√ßa correto, torna-se parte vital da seguran√ßa de seu aplicativo. A autentica√ß√£o baseada em token garante que cada solicita√ß√£o a um servidor seja acompanhada por um token assinado,  que o servidor verifica a sua autenticidade e s√≥ ent√£o responde √† solicita√ß√£o. Um bom exemplo do uso do Token, s√£o os aplicativos de Internet Banking, que em todas as transa√ß√µes financeiras gera um novo token para autorizar a opera√ß√£o.

<div align="center"><img src="https://i.imgur.com/ETfJYCg.png?1" title="source: imgur.com" /></div>

A imagem acima, ilustra um **Token no formato Bearer**. Para cada usu√°rio autenticado no sistema, ser√° gerado um Token, com prazo de validade, que posteriormente ser√° enviado no Cabe√ßalho de todas Requisi√ß√µes HTTP. Requisi√ß√µes HTTP sem um Token v√°lido ser√£o rejeitadas pelos endpoints protegidos da aplica√ß√£o. A valida√ß√£o de um Token funciona como um funil, onde s√≥ passam as Requisi√ß√µes que possuem um Token v√°lido, mesmo com o usu√°rio estando autenticado.

<br />

<h4>1.2.1. Por que precisamos do Token?</h4>



Quando voc√™ envia uma Requisi√ß√£o HTTP para uma API, se o recurso precisar de autoriza√ß√£o para acessar, primeiro voc√™ precisa provar que possui a autoriza√ß√£o e faz isso enviando seu nome de usu√°rio e senha. Agora, imagine que voc√™ precise acessar os recursos desse servidor v√°rias vezes. Nessa situa√ß√£o, voc√™ precisaria enviar o seu nome de usu√°rio e senha em todas as tentativas de acessar o recurso.

Voc√™ n√£o precisaria fazer isso se a sua aplica√ß√£o guardasse o estado atual da autentica√ß√£o. Entretanto, vamos relembrar que uma API REST n√£o guarda o estado, ou seja, uma Requisi√ß√£o n√£o depende e/ou utiliza dados de uma Requisi√ß√£o anterior, logo √© necess√°rio encontrar outra maneira de autorizar os usu√°rios, em vez de solicitar o nome de usu√°rio e a senha em todas as solicita√ß√µes.

Como solu√ß√£o para este problema, surge a **Autoriza√ß√£o Baseada em Token**. Quando voc√™ entra em um sistema fornecendo seu nome de usu√°rio e senha, o sistema gera um Token para voc√™ com os dados de autoriza√ß√£o necess√°rios dentro dele. Esse Token √© enviado a voc√™ como resposta √† sua Requisi√ß√£o de autentica√ß√£o. Para qualquer Requisi√ß√£o de acesso a recursos do servidor, voc√™ pode enviar esse Token em vez de enviar o seu nome de usu√°rio e senha.

<br />

<h3>1.3. Autoriza√ß√£o</h3>

<div align="center"><img src="https://i.imgur.com/kazNpLz.png" title="source: imgur.com" /></div>

√â o segundo processo da Seguran√ßa da Informa√ß√£o, popularmente conhecido como Direitos de acesso (Roles) no sistema. √â o momento em que o sistema checar√° o que o usu√°rio pode e n√£o pode fazer no sistema, ou seja, as suas permiss√µes dentro do sistema (Quais Recursos e Endpoints podem ser acessados?). Estas permiss√µes s√£o chamada de **Roles**. Independente de possuir um Token v√°lido, o usu√°rio s√≥ ter√° acesso ao Recurso se possuir a autoriza√ß√£o para acess√°-lo.

<br />

<h2>2. Conhecendo o HTTP Authentication</h2>



O **IETF (*Internet Engineering Task Force*)** tem como miss√£o identificar e propor solu√ß√µes para as quest√µes/problemas relacionados √† utiliza√ß√£o da Internet, al√©m de propor a padroniza√ß√£o das tecnologias e protocolos envolvidos. O mesmo define a estrutura de autentica√ß√£o HTTP que pode ser usada por um servidor para definir uma solicita√ß√£o do cliente. Numa autentica√ß√£o por token, o servidor responde ao cliente com uma mensagem do tipo **HTTP Status 401 (N√£o autorizado)** e fornece informa√ß√µes de como autorizar com um cabe√ßalho de resposta **WWW-Authenticate** contendo ao menos uma solicita√ß√£o. Um cliente que deseja autenticar-se com um servidor pode fazer isso incluindo um campo de cabe√ßalho de solicita√ß√£o **WWW-Authenticate** com as credenciais. No Diagrama de Sequ√™ncia abaixo pode se observar este relacionamento:

<div align="center"><img src="https://i.imgur.com/skGtKqr.png" title="source: imgur.com" /></div>

No caso de uma **Autoriza√ß√£o ‚ÄúBearer‚Äù** (como a mostra a figura acima), a troca deve acontecer por meio de uma conex√£o HTTP (TLS) para ser segura. Se um servidor recebe credenciais v√°lidas, mas que n√£o s√£o adequadas para ter acesso a um determinado recurso, o servidor responder√° com o c√≥digo de status **HTTP Status 403 (Proibido!)**.  Ao contr√°rio de **HTTP Status 401(N√£o autorizado)**, a autentica√ß√£o √© imposs√≠vel para este usu√°rio. 

Essa Autoriza√ß√£o √© enviada no **Cabe√ßalho da Requisi√ß√£o HTTP**, na chave **Authorization**, atrav√©s de uma String que cont√©m as credenciais para autenticar um agente usu√°rio em um servidor.  Aqui o tipo √© novamente necess√°rio, seguido pelas credenciais, que podem ser codificadas ou criptografadas dependendo do esquema de autentica√ß√£o usado. No caso acima foi utilizado o **Esquema de Autentica√ß√£o Bearer** que ser√° explicado na sequencia.

> **Cabe√ßalho HTTP:** Os cabe√ßalhos HTTP permitem que o cliente e o servidor passem  informa√ß√µes adicionais com a solicita√ß√£o ou a resposta HTTP. Um  cabe√ßalho de solicita√ß√£o √© composto por seu nome *case-insensitive* (n√£o diferencia letras mai√∫sculas e min√∫sculas), chamada de **key** (chave), seguido por dois pontos ':' e pelo seu valor (sem quebras de linha), chamado **value** (valor). 
>
> **WWW-Authenticate:** Define o m√©todo de autentica√ß√£o que deve ser utilizado para conseguir acesso ao recurso.
>
> **Authorization:** Cont√©m as credenciais (token) para autenticar um User-Agent com o servidor.

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status/401" target="_blank"><b>Documenta√ß√£o: HTTP Status Code 401 - Unauthorized</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Status/403" target="_blank"><b>Documenta√ß√£o: HTTP Status Code 403 - Forbidden</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/WWW-Authenticate" target="_blank"><b>Documenta√ß√£o: Cabe√ßalho HTTP WWW-Authenticate</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Authorization" target="_blank"><b>Documenta√ß√£o: Cabe√ßalho de Requisi√ß√£o HTTP Authorization</b></a></div>

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers" target="_blank"><b>Documenta√ß√£o: Cabe√ßalhos HTTP</b></a></div>

<br />

<h3>2.1. Esquema Bearer</h3>



A estrutura geral de autentica√ß√£o HTTP √© usado por v√°rios esquemas de autentica√ß√£o. Os esquemas podem divergir na for√ßa da seguran√ßa e na disponibilidade do software cliente ou servidor. Os esquemas mais comuns de autentica√ß√£o s√£o o **Basic** e o **Bearer**, mas existem outros esquemas oferecidos por servi√ßos de hospedagem, como AWS, Google ou Microsoft.

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left">**ATEN√á√ÉO:** Para melhor compreens√£o no momento, vamos focar apenas no entendimento do formato Bearer, que √© considerado um dos esquemas mais populares. Vale mencionar que para aprender os demais √© necess√°rio tempo e muita dedica√ß√£o.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

No projeto Blog Pessoal utilizaremos o esquema **Bearer**, que segundo a sua documenta√ß√£o, consiste em um conjunto de caracteres codificados posicionados ap√≥s a palavra **"Bearer "** (o espa√ßo em branco ap√≥s a palavra Bearer √© obrigat√≥rio), formando um ***Authorization Token*** para ser passado ao sistema. No trecho de c√≥digo abaixo, podemos ver um exemplo simples de um **Token Bearer**:

<div align="center"><img src="https://i.imgur.com/13LBzxE.png" title="source: imgur.com" /></div>

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="100px"/> | ALERTA DE BSM: Mantenha a Aten√ß√£o aos Detalhes ao escrever o Token no formato Bearer, o mesmo √© representado pela palavra "*Bearer* " com um espa√ßo em branco na frente + um conjunto de caracteres codificados, que s√£o fornecidos ao se autenticar no sistema. |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

<div align="left"><img src="https://i.imgur.com/cDPH4tl.png" title="source: imgur.com" width="30px"/> <a href="https://developer.mozilla.org/pt-BR/docs/Web/HTTP/Headers/Authorization" target="_blank"><b>Documenta√ß√£o: Cabe√ßalho de Requisi√ß√£o HTTP Authorization</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://www.rfc-editor.org/rfc/rfc6750.html" target="_blank"><b>Documenta√ß√£o: Esquema de autentica√ß√£o Bearer</b></a></div>

<br />

<h2>3. O Token JWT</h2>



Existem diversas maneiras de gerar um **Token Bearer**, no Projeto Blog Pessoal, utilizaremos o padr√£o **JWT - JSON WEB Token**. O JWT √© um padr√£o de mercado, muito popular e amplamente utilizado, que define como transmitir e armazenar objetos JSON de forma compacta e segura entre diferentes aplica√ß√µes. Os dados nele contidos  podem ser validados a qualquer momento pois o token √© assinado digitalmente. Na imagem abaixo, vemos a estrutura de um Token JWT:

<div align="center"><img src="https://i.imgur.com/EEoVRt4.png" title="source: imgur.com" /></div>

Um Token JWT √© formado por tr√™s se√ß√µes: **Header, Payload e Signature.**

O **Header** (cabe√ßalho do token) √© um objeto JSON que define as informa√ß√µes sobre o tipo do token (typ), nesse caso JWT, e o algor√≠tmo de criptografia usado em sua  assinatura (alg), normalmente **HMAC SHA256**. No c√≥digo abaixo, vemos um exemplo de cabe√ßalho:

```json
{
  "alg": "HS256"
}
```

O **Payload** √© um objeto JSON que cont√©m as **claims** (informa√ß√µes) da entidade tratada, normalmente o usu√°rio autenticado.

Essas claims podem ser de 3 tipos:

| Tipo         | Descri√ß√£o                                                    |
| ------------ | ------------------------------------------------------------ |
| **Reserved** | S√£o os atributos n√£o obrigat√≥rios (mas recomendados), que s√£o usados na valida√ß√£o do token pelos protocolos de seguran√ßa das APIs. |
| **Public**   | S√£o os atributos que usamos em nossas aplica√ß√µes. Normalmente armazenamos as informa√ß√µes do usu√°rio autenticado na aplica√ß√£o. |
| **Private**  | S√£o os atributos definidos especialmente para compartilhar informa√ß√µes entre aplica√ß√µes, tais como nome do usu√°rio e os direitos de acesso (**Roles:** admin, usuario comum, entre outros). |

Na tabela abaixo, temos a lista com as principais Claims utilizadas no payload:

| Claim                | Descri√ß√£o                                                    |
| -------------------- | ------------------------------------------------------------ |
| **sub (subject)**    | Entidade √† quem o token pertence.                            |
| **iss (issuer)**     | Emissor do token.                                            |
| **exp (expiration)** | Timestamp de quando o token ir√° expirar. Observe que a data e hora est√£o em milissegundos. |
| **iat (issued at)**  | Timestamp de quando o token foi criado. Observe que a data e hora est√£o em milissegundos. |
| **aud (audience)**   | Destinat√°rio do token, representa a aplica√ß√£o que ir√° us√°-lo. |

<br />

No c√≥digo abaixo, vemos um exemplo de payload:

```json
{
  "sub": "admin@email.com.br",
  "iat": 1677556617,
  "exp": 1677560217
}
```

Observe que a Claim iat e a Claim exp s√£o inseridas pelo gerador do Token.

<br />

| <img src="https://i.imgur.com/vVDBDG0.png" title="source: imgur.com" width="100px"/> | ALERTA DE BSM: Mantenha a Aten√ß√£o aos Detalhes ao criar o Token JWT. Por seguran√ßa recomenda-se n√£o armazenar informa√ß√µes confidenciais ou sens√≠veis no payload do token como a senha, por exemplo. |
| ------------------------------------------------------------ | :----------------------------------------------------------- |

<br />

A **Signature** (assinatura) √© a concatena√ß√£o da String gerada a partir da **codifica√ß√£o do Header** atrav√©s do algoritmo de codifica√ß√£o **base64UrlEncode**, um **ponto final** (.), a String gerada a partir da **codifica√ß√£o do Payload** atrav√©s do algoritmo de codifica√ß√£o **base64UrlEncode**, um **ponto final** (.) e a String gerada a partir da **codifica√ß√£o da SECRET** (Uma String de 256 bits, aleat√≥ria, gerada atrav√©s de um Algoritmo hash), atrav√©s do algoritmo de codifica√ß√£o **base64UrlEncode**. A String Gerada a partir desta concatena√ß√£o, ser√° criptografada com o algoritmo **HMAC SHA256** ou outro Algoritmo indicado no Header do Token, gerando a assinatura do Token JWT. Veja o modelo de gera√ß√£o da assinatura na imagem abaixo:

<div align="center"><img src="https://i.imgur.com/VJfphbU.png" title="source: imgur.com" /></div>

Observe que as sess√µes s√£o concatenadas com um ponto (.), separando as sess√µes, seguindo a estrutura: **header.payload.secretKey**. Observe que a Codifica√ß√£o em Base 64 da SECRET est√° habilitada no Debugger.

| <img src="https://i.imgur.com/hOgWvSc.png" title="source: imgur.com" width="100px"/> | <div align="left">**ATEN√á√ÉO:** N√£o se preocupe em aprender como cada um destes algoritmos de codifica√ß√£o e criptografia funcionam internamente. O mais importante agora √© saber que eles existem e como us√°-los.</div> |
| ------------------------------------------------------------ | ------------------------------------------------------------ |

A assinatura do Token JWT √© usada para verificar se o remetente do JWT √© quem diz ser e para garantir que a mensagem n√£o foi alterada ao longo do caminho. Juntando tudo a sa√≠da s√£o **tr√™s Strings Codificadas em Base64 separadas por pontos**, que podem ser facilmente passadas em ambientes HTML e HTTP, por serem bem compactas.

Na imagem abaixo vemos o Token JWT da primeira imagem deste t√≥pico decodificado:

<div align="center"><img src="https://i.imgur.com/ps4fPwX.png" title="source: imgur.com" /></div>

Para decodificar o Token JWT, foi utilizada a **Ferramenta Debugger do JWT**. Com ela √© poss√≠vel **decodificar o cabe√ßalho e o payload**, como mostra a figura abaixo:

**Token:** 

```bash
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1bmlxdWVfbmFtZSI6ImFkbWluQGVtYWlsLmNvbS5iciIsIm5iZiI6MTY5MDkzMTUxOSwiZXhwIjoxNjkwOTMxNTc5LCJpYXQiOjE2OTA5MzE1MTl9.syQQsU-uxUPQXshz0WTlk9fqYYfjv11rBZhEQAG8SDI
```

**Decodifica√ß√£o:**

<div align="center"><img src="https://i.imgur.com/HbQM6ly.png" title="source: imgur.com" /></div>

Para decodificar o Token JWT, insira a parte **encriptada do Token** (tudo menos a palavra Bearer) no campo **Encoded**, marque o item **secret base64 encoded** e conferir o resultado no campo **Decoded**. A  Assinatura n√£o √© t√£o simples de decodificar, porqu√™ al√©m de usar o Algoritmo **HMAC SHA256**, tamb√©m seria necess√°rio criar um algoritmo espec√≠fico para checagem de Chave P√∫blica e Chave Privada, al√©m de conhecer a Secret Key previamente.

<br />

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="35px"/> <a href="https://jwt.io/introduction" target="_blank"><b>Documenta√ß√£o: JWT - JSON WEB Token</b></a></div>

<div align="left"><img src="https://i.imgur.com/WeNdbPo.png" title="source: imgur.com" width="35px"/> <a href="https://jwt.io/#debugger-io" target="_blank"><b>Ferramenta: JWT Debugger</b></a></div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://pt.wikipedia.org/wiki/Base64" target="_blank"><b>Artigo: Modelo Base 64</b></a> - Como funciona o modelo de Codifica√ß√£o Base 64.</div>

<div align="left"><img src="https://i.imgur.com/RlHVydi.png" title="source: imgur.com" width="25px"/> <a href="https://pt.wikipedia.org/wiki/HMAC" target="_blank"><b>Artigo: Modelo HMAC SHA256</b></a> - Como funciona o modelo de Codifica√ß√£o HMAC SHA256.</div>

<br />

O Token gerado ser√° enviado no Header (cabe√ßalho) de todas as Requisi√ß√µes com endpoints protegidos. Se o token n√£o for enviado, todos os endpoints protegidos por autentica√ß√£o retornar√£o como resposta o status acesso negado (**UNAUTHORIZED ü°™ 401**).

<br />

<h2>3. Seguran√ßa da Aplica√ß√£o ASP.NET</h2>



Analisando nosso projeto Blog Pessoal podemos perceber que nossa API, at√© este momento, n√£o possui nenhuma seguran√ßa, ou seja, qualquer pessoa acessa todos os endpoints de todos os m√≥dulos livremente. A maioria das aplica√ß√µes que s√£o desenvolvidas cont√©m informa√ß√µes vitais como: dados pessoais, dados banc√°rios, entre outros, e portanto precisamos garantir que a aplica√ß√£o e estes dados estejam devidamente protegidos de acesso n√£o autorizados. Para criar esta prote√ß√£o nos aplicativos ASP.NET podemos contar com um conjunto de Bibliotecas, que combinadas, criam a seguran√ßa da aplica√ß√£o. Na tabela abaixo temos a lista de pacotes:

| Pacote                       | Descri√ß√£o                                                    |
| ---------------------------- | ------------------------------------------------------------ |
| **Authentication.JwtBearer** | Pacote que permite que um aplicativo ASP.NET receba um Token Bearer JWT. |
| **IdentityModel.Tokens.Jwt** | Pacote respons√°vel por Incluir tipos que fornecem suporte para criar, serializar e validar JSON Web Tokens (JWT). |
| **BCrypt.Net-Core**          | Pacote respons√°vel por criptografar a senha, atrav√©s do algoritmo BCrypt. |

Os Pacotes acima ser√£o utilizados para criar um modelo de seguran√ßa do tipo **Autentica√ß√£o - Token-Based**, com o Token no formato JWT. Para outros modelos de autentica√ß√£o, seria necess√°rio instalar outros pacotes.

Nos aplicativos Web modernos, a autentica√ß√£o pode ser realizada de v√°rias maneiras. A autentica√ß√£o mais comum √© o famoso login, onde os usu√°rios fornecem um nome de usu√°rio (geralmente o e-mail) e uma senha. As redes sociais, criaram o chamado **login √∫nico (SSO - Single sign-on)** usando o Facebook, o Google, o Github, entre outros como meio de autentica√ß√£o. Inova√ß√µes recentes permitem que as pessoas fa√ßam login usando impress√£o digital ou reconhecimento facial. 

> **SSO:** Single sign-on √© um esquema de autentica√ß√£o que permite que um usu√°rio efetue login com um √∫nico usu√°rio e senha em qualquer um dos v√°rios sistemas de software relacionados, mas independentes.

Para oferecer suporte a aplicativos da Web, bem como aplicativos m√≥veis e desktop nativos, a l√≥gica do lado do servidor pode ser exposta como uma API que √© invocada por aplicativos executados em um desktop, dispositivo m√≥vel ou em um navegador executando JavaScript do lado do cliente. O acesso √†s API's √© protegido por credenciais baseadas em token, normalmente emitidos durante o processo de autentica√ß√£o.  

<br />

<h3>3.1 Modelos de Autentica√ß√£o</h3>



Existem v√°rios modelos de autentica√ß√£o, na imagem abaixo, vemos os modelos mais utilizados:

<div align="center"><img src="https://i.imgur.com/tSIBSoU.png?1" title="source: imgur.com" /></div>

**Autentica√ß√£o baseada em sess√£o:** Utiliza cookies do navegador junto com ‚Äúsess√µes‚Äù de back-end para gerenciar usu√°rios conectados e desconectados.     

**Autentica√ß√£o Baseada em Token:** √â um m√©todo de autentica√ß√£o sem estado em que um token √© armazenado no navegador (geralmente no **Local Storage**). Esse token possui informa√ß√µes sobre um usu√°rio e s√≥ pode ser decodificado usando um segredo armazenado no servidor (chave ou secret key). 

> **Local Storage:** Amplamente utilizado por pessoas desenvolvedoras Front-end, √© um mecanismo b√°sico para se guardar  informa√ß√µes do usu√°rio no Navegador. O Local Storage mant√©m o dado gravado mesmo se o Navegador for fechado e reaberto. Isso facilita criar alguns comportamentos de interface durante o uso do usu√°rio.

**Autentica√ß√£o OAuth:** √â um m√©todo de autentica√ß√£o moderno em que um aplicativo usa outro aplicativo para autenticar seus pr√≥prios usu√°rios. Em outras palavras, trata-se de autentica√ß√£o em que um servi√ßo existente (como o Google) lida com a autentica√ß√£o e o armazenamento de usu√°rios enquanto seu aplicativo aproveita esse fluxo para autenticar usu√°rios.

No projeto Blog Pessoal vamos utilizar a **Autentica√ß√£o Baseada em Token JWT**.

<br />

<h3>3.2 Implementa√ß√£o da Seguran√ßa</h3>



Vamos implementar a Seguran√ßa da aplica√ß√£o em 2 etapas distintas:

- **Autentica√ß√£o:** O processo de login
- **Valida√ß√£o do Token:** O Processo de validar o Token de um usu√°rio autenticado, enviado no Cabe√ßalho das Requisi√ß√µes.

<br />

<h4>3.2.1 Autentica√ß√£o</h4>



A **Autentica√ß√£o faz o login do usu√°rio atrav√©s de um usu√°rio e uma senha (credenciais)**. 

Na imagem abaixo, vemos um resumo deste processo:

<div align="center"><img src="https://i.imgur.com/0qECZwm.png" title="source: imgur.com" /></div>

1. O Usu√°rio informa as suas credenciais (usu√°rio e senha);
2. Uma **Requisi√ß√£o HTTP do tipo POST** √© gerada e as credenciais s√£o enviadas no Corpo da Requisi√ß√£o, no formato JSON;
3. O HTTP Context recebe a requisi√ß√£o e encaminha para o **Middleware**, que verificar√° se o Endpoint √© protegido.
4. Se o Endpoint for protegido, o Middleware checa se existe um Token na Requisi√ß√£o. Caso n√£o possua, encaminha para o **Middleware Authentication**.
5. O **Middleware Authentication** verifica se no corpo da requisi√ß√£o foram enviados os **atributos usuario e senha**. 
6. Caso n√£o encontre os 2 atributos, ser√° retornado para o Usu√°rio a Resposta **UNAUTHORIZED ü°™ 401**.
7. Caso encontre os 2 atributos, a Classe **AppAuthService** tentar√° autenticar o usu√°rio. Caso n√£o consiga, ser√° retornado para o Usu√°rio a Resposta **UNAUTHORIZED ü°™ 401**.
8. Caso a autentica√ß√£o tenha sido bem sucedida, a Classe **AppAuthService** ir√° gerar o **Token JWT**, atrav√©s da Classe **IdentityModel**, anexar o Token JWT no Corpo da Resposta da Requisi√ß√£o de Login e retornar√° para o usu√°rio a Resposta **OK ü°™ 200**.

<br />

<h4>3.2.2 Valida√ß√£o do Token</h4>



A **Valida√ß√£o do Token faz a valida√ß√£o do Token JWT** nos endpoints protegidos da aplica√ß√£o. Um ponto muito importante que deve ser destacado √© que a valida√ß√£o **n√£o cria o Token JWT**, ela apenas valida o Token enviado no cabe√ßalho da requisi√ß√£o. 

Na imagem abaixo, vemos um resumo deste processo:

<div align="center"><img src="https://i.imgur.com/Z7t8lgp.png" title="source: imgur.com" /></div>

1. O Usu√°rio cria uma Requisi√ß√£o para Listar todas as Postagens;
2. Uma **Requisi√ß√£o HTTP do tipo POST** √© gerada e o Token √© enviado no Cabe√ßalho da Requisi√ß√£o, no formato JSON;
3. O HTTP Context recebe a requisi√ß√£o e encaminha para o **Middleware**, que verificar√° se o Endpoint √© protegido.
4. Se o Endpoint for protegido, o Middleware checa se existe um Token na Requisi√ß√£o. Caso n√£o possua, encaminha para o **Middleware Authentication**.
5. Caso possua um Token, este Token ser√° validado (TokenValidation). Este processo √© realizado pela Classe **IdentityModel**.
6. Caso o Token n√£o seja validado, ser√° retornado para o Usu√°rio a Resposta **UNAUTHORIZED ü°™ 401**.
7. Caso o Token seja validado, o **Middleware Authorization** validar√° as Permiss√µes do usu√°rio. Caso o usu√°rio n√£o possua as permiss√µes necess√°rias para acessar o endpoint, ser√° retornado para o Usu√°rio a Resposta **FORBIDDEN ü°™ 403** e n√£o adianta tentar autenticar novamente, porque √© uma quest√£o de direitos de acesso.
8. Caso o usu√°rio possua as permiss√µes necess√°rias para acessar o endpoint, o **Middleware AppController** ir√° redirecionar a Requisi√ß√£o para a Classe Controladora, que responde pelo endere√ßo da Requisi√ß√£o e o usu√°rio receber√° a Resposta da Requisi√ß√£o.

> Em termos pr√°ticos, **Middleware** seria um trecho de c√≥digo que pode ser  executado no fluxo de execu√ß√£o da aplica√ß√£o. No ASP.NET os Middleware s√£o organizados em um pipeline e s√£o executados conforme uma solicita√ß√£o √© recebida e uma resposta enviada. Os Middlewares s√£o executados na sequ√™ncia em s√£o instanciados dentro da Classe, por isso √© muito importante tomar cuidado com a ordem dos servi√ßos. 
>
> **Exemplo:** *N√£o adianta Autorizar o acesso de um usu√°rio, sem Autenticar primeiro, porque o Token n√£o ser√° gerado.*
>
> Na Classe Program, todos os Servi√ßos que come√ßam com Use, Map ou Run s√£o Middlewares que pertencem ao Fluxo de Execu√ß√£o da Aplica√ß√£o (Pipeline).

Nos pr√≥ximos conte√∫dos vamos implementar a Seguran√ßa da Aplica√ß√£o ASP.NET...

<br /><br />

<div align="left"><a href="README.md"><img src="https://i.imgur.com/XMgF3gl.png" title="source: imgur.com" width="3%"/>Voltar</a></div>